\section{ХОД РАБОТЫ}

\subsection{Текст задания}

Необходимо написать три функции, которые будут
вызываться из функции main():
\begin{itemize}
\item
  первая функция получает размерность
  массива, создает динамический массив и возвращает указатель на начало
  созданного массива;
\item
  вторая --- получает адрес массива и его размерность
  и решает одну из ниже перечисленных задач;
\item
  третья функция получает
  адрес массива и его размерность и освобождает память, занятую
  массивом.
\end{itemize}

Размерность вводится с клавиатуры в функции main() и
передается в первую функцию. 
Значения элементов вводятся с клавиатуры.
Для управления памятью использовать соответствующие функции Win32 API.

\subsection{Теоретические сведения}

Под управлением памятью имеются в виду возможности программы по размещению и манипулированию данными. Поскольку единственным «представителем» памяти в программе выступают переменные, то управление памятью определяется тем, каким образом работает с ними и с образованными ими структурами данных язык программирования. 

Большинство языков программирования однозначно закрепляет за переменными их типы данных и ограничивает работу с памятью только теми областями, в которых эти переменные размещены. Программист не может выйти за пределы самим же определенного шаблона структуры данных. С другой стороны, это позволяет транслятору обнаруживать допущенные ошибки как в процессе трансляции, так и в процессе выполнения программы. 

В языке Си ситуация принципиально иная по двум причинам. Во-первых, наличие операции адресной арифметики при работе с указателями позволяет, в принципе, выйти за пределы памяти, выделенной транслятором под переменную и адресовать память как «до» так и «после» нее. Другое дело, что это должно производиться осознанно и корректно. Во-вторых, присваивание и преобразование указателей различных типов, речь о котором пойдет ниже, позволяет рассматривать одну и ту же память «под различным углом зрения» в смысле типов заполняющих ее переменных:

\begin{itemize}
\item Двумерный массив всегда реализован как одномерный массив с количеством
  элементов, соответствующих первому индексу, причем каждый элемент
  представляет собой массив элементов базового типа с количеством,
  соответствующим второму индексу.
\item Идентификатор массива без скобок интерпретируется как адрес нулевого
  элемента нулевой строки, или указатель на базовый тип данных.
\item Имя двумерного массива с единственным
  индексом интерпретируется как начальный адрес соответствующего
  внутреннего одномерного массива. A[i] понимается как \&A[i][0], то есть
  начальный адрес i-го массива символов.
\end{itemize}

Сказанное справедливо и для N-мерных массивов: многомерный массив представляет собой массив элементов первого индекса, каждый из который представляет собой массив элементов второго индекса и т.д.

Для работы с динамической памятью в WinAPI предусмотрены функции,
изображенные на рисунке~\ref{lst:WinAPI}.

\begin{lstlisting}[caption=Функции WinAPI для работы с памятью,label=lst:WinAPI]
void * GlobalAlloc(uiFlags, dwSize);
void * GlobalReAlloc(p, dwSize, uiFlags);
GlobalSize(void *);
GlobalFree(void *);
\end{lstlisting}

За исключением одной, для каждой функции, начинающейся со слова Global, существует другая, начинающаяся со слова Local. Эти два набора функций в Windows идентичны. Два различных слова сохранены для совместимости с предыдущими версиями Windows, где функции Global возвращали дальние указатели, а функции Local – ближние.

\pagebreak

\subsection{Особенности разработанной программы}

Разработанная 
программа имеет следующие функциональные особенности:

\begin{itemize}
\item интерактивный консольный интерфейс, устойчивый к ошибкам переполнения;
\item осуществление проверки корректности вводимых данных с возможностью 
  замены некорректных данных;
\item разделение различных функциональных частей исходного кода программы 
  по различным файлам с исходным кодом;
\item реализована поддержка инкрементальной компиляции.
\end{itemize}

Для захвата памяти, необходимой для размещения двумерного массива,
была разработана функция, представленная на рисунке~\ref{lst:create_array}.

\begin{lstlisting}[caption=Функция создания двумерного динамического массива,label=lst:create_array]
int ** create_array(int N, int M)
{
  int i; const int uiFlags = 0; int ** a;

  a = (int **)GlobalAlloc(uiFlags, sizeof(int *) * N);
  if (a)
    {
      for (i = 0; i < N; i++)
	{
	  a[i] = (int *)GlobalAlloc(uiFlags, sizeof(int) * M);
	  if (!(a[i]))
	    {
	      for (i = i-1; i >=0; i--)
		GlobalFree(a[i]);	    
	      GlobalFree(a);
	      return NULL;
	    }
	}
      return a;
    }
  else
    return NULL;
}
\end{lstlisting}

Функция поиска наименьшего элемента в двумерном массиве была использована 
функция, представленная на рисунке~\ref{lst:array_get_min}.

\begin{lstlisting}[caption=Функция поиска минимального элемента в массиве,label=lst:array_get_min]
int
array_get_min(int ** array, int N, int M)
{
  int i, j, min = array[0][0];
  for (i = 0; i < N; i++)
    {
      for (j = 0; j < M; j++)
	{
	  if (array[i][j] < min)
	    min = array[i][j];
	}
    }
  return min;
}
\end{lstlisting}

Для освобождения памяти, отведенной под размещение двумерного массива,
была разработана функция, представленная на рисунке~\ref{lst:destroy_array}.

\begin{lstlisting}[caption=Функция освобождения памяти,label=lst:destroy_array]
void destroy_array(int ** array, int N, int M)
{
  int i;
  for (i = 0; i < N; i++)
    {
      GlobalFree(array[i]);
    }

  GlobalFree(array);
  array = NULL;
}
\end{lstlisting}

Полный исходный текст разработанной программы расположен в приложении А.

\newpage
