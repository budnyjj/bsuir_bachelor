\section[Анализ предметной области]{АНАЛИЗ ПРЕДМЕТНОЙ ОБЛАСТИ}

\subsection{Основные понятия предметной области}

Приведем основные определения понятий, необходимые для понимания предметной
области.

\textit{Событиями} в операционной системе являются любые действия пользователя~(события
клавиатуры, мыши), поступающие сообщения от других программ и потоков, а также
любые сетевые сообщения, например, поступление сетевого пакета.

\textit{Потоком событий} называется последовательность однородных событий,
следующих одно за другим в какие-либо случайные моменты времени.

Говоря о потоке событий, нужно иметь в виду, что здесь термин <<событие>>
имеет значение, несколько отличное от того, которое вводится в процессе
изучения курса теории вероятностей. Там <<событием>> (<<случайным событием>>)
называется какой-то исход опыта, обладающий той или иной вероятностью.
События, образующие поток, сами по себе вероятностью не обладают; вероятностями
обладают другие, производные от них события, например: <<на интервал времени
$[a;b]$ попадает ровно два события>>, и так далее~\cite{ventcel_issled_op}.

Поток событий называется
\textit{стационарным}, если вероятность попадания того или иного числа
событий на участок времени длиной $\tau$ зависит только от длины участка
и не зависит от того, где именно на оси расположен этот участок.

Поток событий называется \textit{потоком без последствия}, если для любых
непересекающихся участков времени число событий, попадающих на один из них,
не зависит от того, сколько событий попало на другой участок.
Отсутствие последствия в потоке означает, что события, образующие поток,
появляются в последовательные моменты времени независимо друг от друга.

Поток событий называется \textit{ординарным}, если вероятность попадания
на элементарный участок двух или более событий пренебрежительно мала
по сравнению с вероятностью попадания одного события на этот участок.

Поток событий, обладающий всеми тремя свойствами, описанными
ранее~(стационарность, поток без последствия, ординарность), называется
\textit{простейшим} (или стационарным пуассоновским).
Нестационарный пуассоновский поток обладает только свойством ординарности и
является потоком без последствия~\cite{ventcel_tv}.

Под \textit{мониторингом} понимают непрерывный процесс наблюдения и регистрации
параметров объекта, в сравнении с заданными критериями.

Мониторинг потока событий в рамках операционной системы --- это
отслеживание всевозможных действий, совершаемых пользователем персонального
компьютера (нажатие клавиши на клавиатуре, щелчок мыши), реакция на
поступающие сообщения от других программ и потоков, отправку
сетевых пакетов и так далее.

\subsection{Средства мониторинга потока событий}
\label{sub:monitoring_tools}

Средства мониторинга потока событий можно разделить на зависимые и независимые
от операционной системы. К независимым от ОС средствам можно отнести некоторые
языки программирования, используемые в веб-технологиях на стороне клиента.

Например, с помощью языка JavaScript можно достаточно просто получить информацию
о количестве переходов по конкретной ссылке на веб-странице, предпочтении одного
баннера другому. Идеи обработки событий в языках программирования постепенно
сформировались в парадигму событийно-ориентированного программирования.

Событийно-ориентированное программирование --- способ построения компьютерных
программ, при котором в коде явным образом выделяется главный цикл приложения,
тело которого состоит из двух частей: выборки события
и обработки события~\cite{wiki_event_driven_p}.

С точки зрения применения парадигмы событийно-ориентированного программирования
в настольных приложениях следует отметить, что в современных языках программирования
события и обработчики событий являются центральным звеном реализации
графического интерфейса пользователя. Рассмотрим, к примеру,
взаимодействие программы с событиями от мыши. Нажатие правой клавиши мыши
вызывает системное прерывание, запускающее определенную процедуру внутри
операционной системы. В этой процедуре происходит поиск окна,
находящегося под курсором мыши. Если окно найдено, то данное событие посылается
в очередь обработки сообщений этого окна. Далее, в зависимости от типа окна,
могут генерироваться дополнительные события. Например, если окно является
кнопкой~(в Windows все графические элементы являются окнами), то дополнительно
генерируется событие нажатия на кнопку. Отличие последнего события в том,
что оно более абстрактно, а именно, не содержит координат курсора, а говорит
просто о том, что было произведено нажатие на данную кнопку.

Пример обработчика события на языке С\# приведен на рисунке~\ref{lst:button_pressed}.
\begin{lstlisting}[basicstyle=\scriptsize\ttfamily,
                   numberstyle=\scriptsize\ttfamily,
                   xleftmargin=7mm,
                   language=C++,caption=Пример обработчика событий на языке C\#,
                   label=lst:button_pressed]
private void button1_Click(object sender, EventArgs e)
{
    MessageBox.Show("Button was pressed.");
}
\end{lstlisting}

В приведенном примере обработчик события представляет собой процедуру, в которую
передается параметр \texttt{sender}, как правило содержащий указатель на
источник события. Это позволяет использовать одну и ту же процедуру
для обработки событий от нескольких кнопок, различая их по этому параметру.

К платформозависимым системам, используемым для мониторинга потока событий
можно отнести инструментарий управления Windows~(Windows Managment
Instrumentation, WMI).

WMI --- технология управления Windows-компьютерами, реализующая
стандарты Web-управления предприятием~(WBEM, Web-based Enterprise Managment).
Технология WMI реализована для всех операционных систем семейства Windows,
начиная с Windows 95. Однако устанавливается подсистема по умолчанию только
в Windows Millennium Edition, Windows~2000, Windows XP, Windows Server 2003 и
последующих операционных системах. Для других поддерживаемых версий Windows
файлы установки доступны для бесплатной загрузки.

Практическое использование WMI для получения данных о состоянии оборудования
или программной среды во многом напоминает работу с базой данных: необходимо
указать, какие параметры должны быть получены от какого объекта и при каких
ограничениях (фильтрах). Язык запросов для WMI так и называют --- WMI Query
Language~(WQL). Даже команды WQL принято называть запросами~\cite{sysadmin_practice}.

В рамках WMI реализована служба работы с событиями --- WMI Event Service. Эта
служба поддерживает фильтрацию событий и обеспечение их обработки.

Для того чтобы зарегистрировать событие и иметь возможность его обрабатывать,
необходимо при помощи метода \texttt{ExecNotificationQuery} объекта
\texttt{SWbemServices} выполнить запрос WQL по специальной форме.
Пример такого запроса представлен на рисунке~\ref{lst:wql}.
\begin{lstlisting}[basicstyle=\scriptsize\ttfamily,
                   numberstyle=\scriptsize\ttfamily,
                   xleftmargin=7mm,
                   language=sql,caption=Пример WQL запроса,
                   label=lst:wql]
Set colMonitorProcess =
  objWMIService.ExecNotificationQuery("SELECT * FROM __InstanceOperationEvent " &
  "WITHIN 1 WHERE TargetInstance ISA 'Win32_Process'")
\end{lstlisting}

Представленный на рисунке~\ref{lst:wql} WQL-запрос возвращает экземпляры класса
\texttt{\_\_InstanceOperationEvent}, которые формируются при каждом создании, удалении и
модификации экземпляра WMI класса. Оператор \texttt{WITHIN} определяет интервал времени
в секундах между запросами. Конструкция \texttt{WITHIN 1} говорит о том, что запрос будет
производится каждую секунду. С помощью оператора \texttt{WHERE} происходит фильтрация
события, при этом оператор \texttt{ISA} указывает необходимые события. В приведенном выше
примере происходит фильтрация событий, для которых свойство \texttt{TargetInstance} класса
\texttt{\_\_InstanceOperationEvent} является экземпляром класса \texttt{Win32\_Process}.

Класс \texttt{\_\_InstanceOperationEvent} является родительским для всех событий, вызываемых
экземплярами WMI классов. Приведем потомков класса \texttt{\_\_InstanceOperationEvent}:

\begin{itemize}
  \item \texttt{\_\_InstanceCreationEvent} --- создается при создании нового экземпляра
    WMI класса;
  \item \texttt{\_\_InstanceModificationEvent} --- создается при модификации существующего
    экземпляра WMI класса;
  \item \texttt{\_\_InstanceDeletionEvent} --- создается при уничтожении экземпляра WMI класса.
\end{itemize}

Далее рассмотрим возможности операционной системы OS X по обработке потока
событий. Для обработки потока простейших событий в языке Objective-C существует
класс \texttt{NSEvent}.

Объект класса \texttt{NSEvent} содержит информацию о происходящих в системе событиях,
таких как нажатие клавиши на клавиатуре или щелчок мыши. Таким образом можно
получить информацию о нажатых пользователем клавишах, расположении курсора мыши
и так далее~\cite{appledoc_nsevent}.

Пример обработки нажатия клавиши в языке Objective-C представлен
на рисунке~\ref{lst:objc_example}.
\begin{lstlisting}[basicstyle=\scriptsize\ttfamily,
                   numberstyle=\scriptsize\ttfamily,
                   xleftmargin=7mm,
                   language=C++,caption=Пример обработки нажатия клавиши в Objective-C,
                   label=lst:objc_example]
[NSEvent addGlobalMonitorForEventsMatchingMask:NSKeyDownMask handler:^(NSEvent *event) {
    NSLog(@"Key was pressed.");
}];
\end{lstlisting}

В приведенном на рисунке~\ref{lst:objc_example} примере вызывается метод
\texttt{addGlobalMonitorForEventsMatchingMask} класса \texttt{NSEvent}
с двумя аргументами. Первый параметр указывает, события какого типа должны
отслеживаться системой. Вторым параметром выступает блок, являющийся по сути
обработчиком поступающего события.

Блок в Objective-C представляет собой фрагмент кода, который может
передаваться в программе по аналогии с данными. Такие конструкции определенно
относятся к числу нетривиальных аспектов Objective-C, и на первый взгляд они
кажутся довольно запутанными. Однако в API фирмы Apple блоки встречаются все
чаще. Блоки могут показаться чем-то похожим на указатели функций,
но стоит отметить, что при правильном использовании блоков код получается
более элегантным, чем при использовании указателей на функции~\cite{hillegass}.

\subsection{Постановка задачи}

Требуется разработать программу, которая перехватывает события клавиатуры.
Все события должны протоколироваться в специальном журнале, который может
представлять собой обычный текстовый файл. Предусмотреть в программе возможность
запуска и остановки перехвата событий.

\pagebreak
