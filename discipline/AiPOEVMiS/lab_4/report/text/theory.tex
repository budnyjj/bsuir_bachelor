\section{ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ}

\subsection{Концепция модульного программирования}

Основа концепции модульного программирования --- модуль, который является
продуктом процесса разбиения большой задачи на ряд более мелких функционально
самостоятельных подзадач. Этот процесс называется функциональной декомпозицией
задачи. Каждый модуль в функциональной декомпозиции представляет собой
<<черный ящик>> с одним входом и одним выходом. Модули связаны между собой
только входными и выходными данными.

Модульный подход позволяет безболезненно производить модернизацию программы
в процессе её эксплуатации и облегчает её сопровождение. Дополнительно модульный
подход позволяет разрабатывать части программ одного проекта на разных языках
программирования, после чего с помощью компоновочных средств объединять их в
загрузочный модуль.

\subsection{Связь ассемблера с языками программирования \\ высокого уровня}
\label{sub:asm_and_high_lang}

Рассмотрим возможные формы комбинирования программ на языках высокого уровня
с ассемблером.

Использование операторов типа \textit{inline} и ассемблерных вставок в виде
встраиваемого ассемблерного кода. Эта форма в значительной степени зависит от
синтаксиса языка высокого уровня и конкретного компилятора. Такая форма
бывает полезной, если нужно вставить небольшой фрагмент кода.

Использование \textit{внешних процедур} и \textit{функций.} Это более
универсальная форма комбинирования, у которой есть следующие преимущества:
\begin{itemize}
  \item написание и отладка программ производиться независимо;
  \item написанные подпрограммы могут использоваться в других программах;
  \item облегчается модификация и сопровождение подпрограмм в течение жизненного
    цикла проекта.
\end{itemize}

\pagebreak

В язык C встроить код на ассемблере довольно просто. Для этого необходимо
использовать синтаксис, приведенный на рисунке~\ref{lst:inline_asm_syntax}.

\begin{lstlisting}[caption={Синтаксис встраимого ассемблерного кода в язык C},
label=lst:inline_asm_syntax]
 __asm one_command

 /* or */

 __asm {
   ...
   many_commands
   ...
 }
\end{lstlisting}

Для встраивания ассемблера в язык Pascal нужно преобразовать ассемблерный код
в машинные команды, а затем использовать следующий синтаксис:
\textit{inline(машинные коды)}.

Вариант комбинирования ассемблерного кода и более высокоуровневых языков
программирования с использованием операторов типа inline иммеет
следующие ограничения:
\begin{itemize}
  \item нет возможности определения данных какого-либо типа;
  \item нельзя описывать функции в пределах ассемблерной вставки;
  \item нельзя использовать в командах большинство операторов ассемблера типа offset, lea и др.;
  \item отсутствует возможность использования директив макроопределений;
  \item нельзя обращаться к полям структур и объединений.
\end{itemize}

Так как вариант с использованием операторов inline и ассемблерных вставок обладает
довольно большими ограничениями, он не может быть признан универсальным, и для
реализации сложных задач остаётся организация связи программ на языках высокого
уровня с ассемблерным кодом через внешние процедуры и функции. Возможны два
вида такой связи --- программа на языке высокого уровня вызывает процедуру на
ассемблере и наоборот. Тот случай, когда программа на языке высокого уровня
вызывает процедуру на ассемблере является наиболее часто используемым видом связи.

Синтаксис директивы proc на языке ассемблера выглядит следующим образом:

\textit{имя\_процедуры proc [[модификатор\_языка] язык] [расстояние]}

Оператор \textit{язык} служит для того, чтобы компилятор мог правильно организовать
связь между процедурой на ассемблере и программой на языке высокого
уровня. Необходимость такого указания возникает вследствие того, что способы передачи
аргументов при вызове процедур различны для разных языков высокого уровня.

Наиболее важной особенностью является \textit{направление передачи аргументов}, которое
определяет порядок, в котором аргументы включаются в стек, по сравнению с порядком
их следования в вызове процедуры. Для языка Pascal характерен прямой порядок включения
аргументов в стек: первым в стек записывается первый передаваемый аргумент из
оператора вызова процедуры, вторым --- второй аргумент и т.~д. На вершине стека
после записи всех передаваемых аргументов оказывается последний аргумент.

Для языков C/C++, наоборот, характерен обратный порядок передачи аргументов.
Это делает возможным передачу переменного количества параметров при вызове функций
в языках C/C++.


\subsection{Связь C и Ассемблера}

При передаче и возврате значения из процедуры на ассемблере важно помнить о
соглашениях, указанных в таблице~\ref{tbl:convention}.

\begin{table}[h!]
  \caption{Соглашение о соответствии типов в языках ассемблера и C++}
  \label{tbl:convention}
    \centering
    \small{
    \begin{tabular}{| p{0.47\textwidth} | p{0.47\textwidth} |}
      \hline

      Тип возвращаемого значения (C++) & Место записи результата \\ \hline
      [unsigned] char & AX \\ \hline
      enum & AX \\ \hline
      [unsigned] short & AX \\ \hline
      [unsigned] int & AX \\ \hline
      [unsigned] long & DX:AX \\ \hline
      указатель near & AX \\ \hline
      указатель far & DX:AX \\

      \hline
    \end{tabular}
    }
\end{table}

Очистку стека в языках C/C++ всегда совершает вызывающая продедура. При разработке
программы с использованием только одного языка высокого уровня об этом задумываться
не имеет смысла, но если планируется использование нескольких <<разноязыковых>>
модулей, то эти соглашения нужно иметь в виду.

Процедуры на ассемблере получают доступ к аргументам, переданным в стеке,
посредством регистра BP. Прежде всего, в начале процедуры необходимо вставить
код пролога:

\textit{push bp}

\textit{mov bp,sp}

Первая команда сохраняет содержимое BP в стек, чтобы исключить порчу находящегося
в нём значения в вызываемой в нём процедуре. Вторая команда пролога насраиват BP
на вершину стека. Для доступа к первому аргументу в стеке необходимо
сделать смещение на четыре байта (\textit{bp~+~4}) в случае, если процедура имеет тип near,
и смещение на шесть байтов (\textit{bp~+~6}), если процедура имеет тип far.

Конец процедуры также должен быть оформлен особым образом, обеспечивая корректный
возврат из процедуры. Фрагмент кода, выполняющего такие действия имеет своё
название --- эпилог процедуры. Код эпилога должен восстанавливать контекст программы
в точке вызова процедуры из вызывающей программы.

\pagebreak
