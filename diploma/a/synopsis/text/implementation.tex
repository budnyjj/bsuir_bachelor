\section[Программная реализация приложения]{%
  ПРОГРАММНАЯ РЕАЛИЗАЦИЯ ПРИЛОЖЕНИЯ
}\label{sec:implementation}

\subsection{Выбор программных средств реализации}

% iOS

Операционная система iOS представляет собой систему, которая работает
на устройствах iPhone, iPad и iPod touch. ОС управляет аппаратным обеспечением
и предоставляет инструменты для разработки нативных приложений.
Нативные приложения представляют собой программы, которые могут быть загружены
из магазинов мобильных приложений (App Store для устройств под управлением
операционной системы iOS) и установлены на мобильное устройство.
Важной особенностью нативных приложений является то,
что разработка ведётся под конкретную платформу, требует
от разработчика специализированных знаний для работы в конкретной
среде программирования.

Комплект средств разработки (англ. Software Development Kit, SDK) программного
обеспечения для операционной системы iOS содержит инструменты
и интерфейсы, необходимые для разработки, установки, запуска
и отладки нативных приложений, которые появляются на домашнем экране iOS-устройств.

Саму операционную систему можно рассматривать как набор слоёв,
расположенных на различных логических уровнях. Слоистая архитектура операционной
системы iOS представлена на рисунке~\ref{fig:ios_layers}.
\begin{figure}[h!]
  \centering
  \includegraphics[width=130mm]{fig/ios_layers}
  \caption{Слоистая архитектура \\ операционной системы iOS}
  \label{fig:ios_layers}
\end{figure}

Нижние слои содержат фундаментальные сервисы и технологии.
Слои более высокого уровня опираются на нижние, взаимодействуя с ними,
и обеспечивают доступ к более низкоуровневым сервисам и технологиям.

Слой \textit{Cocoa Touch} содержит ключевые библиотеки для создания iOS-приложений.
Эти фреймворки определяют внешний вид приложений и определяют базовую
инфраструктуру приложений, поддержку ключевых технологий,
таких как многозадачность, сенсорный ввод,
push-уведомления и других высокоуровневых системных сервисов.

Слой \textit{Media} включает в себя графические, аудио- и видеотехнологии,
которые используются для реализации мультимедийных возможностей приложении.

Слой \textit{Core Services} содержит основные системные сервисы. Ключевыми среди
них являются фреймворки Core Foundation и Foundation,
определяющие основные типы, которые используются в приложениях.
Этот слой также включает в себя специфические технологии
для поддержки таких функций, как геолокация, iCloud, сетевые
технологии и другие.

Слой \textit{Core OS} состоит из низкоуровневых функций, на которых базируется
большинство других технологий. Даже если разработчики не используют
эти функции напрямую, они зачастую используются другими библиотеками.
В ситуациях, когда необходимо иметь дело с безопасностью или связью
с аппаратным обеспечением устройства, можно воспользоваться фреймворками этого
слоя.

В процессе создания приложения компания Apple рекомендует отдавать предпочтение
использованию фреймворков более высокого уровня. Библиотеки более высокого
уровня предоставляют собой объектно-ориентированные абстракции
для конструкций более низкого уровня.
Использование библиотек низкого уровня допускается,
если они содержат компоненты, недоступные в фреймворках
более высокого уровня~\cite{ios_core_layers}.

В результате iOS выступает в качестве посредника между низкоуровневым
аппаратным обеспечением устройства и приложениями, которые создают разработчики.
Приложения не взаимодействуют напрямую с аппаратным обеспечением,
они общаются с оборудованием через набор четко определенных системных интерфейсов.
Эти интерфейсы позволяют легко создавать приложения,
которые при этом остаются безопасными для конечного пользователя.

% Xcode & AppCode

Интегрированная среда разработки Xcode --- это пакет средств разработки,
которая используется для создания,
тестирования, отладки и конфигурации iOS-приложений. Среда разработки Xcode
включает в себя приложение Xcode, которое является оболочкой для инструментов
создания приложений, инструменты для отладки и iOS-симулятор.
Для написания и отладки кода используется приложение Xcode,
тестирование происходит путем запуска приложения на iOS симуляторе
или на непосредственно подключенным устройстве под управлением операционной системы iOS.
Для измерения производительности используются инструменты,
которые могут быть запущены из приложения Xcode.

Пользовательский интерфейс среды разработки Xcode представлен
на рисунке~\ref{fig:xcode}.
\begin{figure}[h!]
  \centering
  \includegraphics[width=150mm]{fig/xcode}
  \caption{Пользовательский интерфейс \\ среды разработки Xcode}
  \label{fig:xcode}
\end{figure}

Среда разработки Xcode включает в себя ряд возможностей, среди которых:
\begin{itemize}
  \item встроенный редактор Interface Builder для создания пользовательского
    интерфейса приложения;
  \item расширенная подсветка синтаксиса;
  \item использование официальной документации Apple непосредственно в среде разработки;
  \item система сборки проекта, проверка зависимостей;
  \item компиляция кода с использованием LLVM и Clang;
  \item статический анализатор для контроля поведения приложения и выявления
    потенциальных проблем;
  \item комплексная отладка приложения с использованием дебаггера lldb.
\end{itemize}

Стоит отметить, приложение Xcode не является монополистом на рынке
интегрированных сред разработки программных продуктов для платформы iOS и OS X.
Весной 2013 года компания JetBrains представила IDE для создания приложений для
устройств Apple. По словам разработчиков, AppCode призвана облегчить
повседневную работу программистам, разрабатывающим на Objective-C и Swift
приложения для устройств Apple, таких как Mac, iPhone, iPad, Apple Watch и Apple TV.
Для повышения их продуктивности среда разработки AppCode тесно интегрируется с приложением
Xcode и сосредоточена на обеспечении качества кода за счет удобной
навигации по коду, оптимизированному автодополнению, анализу кода
на лету (с мгновенным исправлением обнаруженных проблем)
и автоматизированному рефакторингу.

Пользовательский интерфейс среды разработки AppCode представлен
на рисунке~\ref{fig:appcode}.
\begin{figure}[h!]
  \centering
  \includegraphics[width=150mm]{fig/appcode}
  \caption{Пользовательский интерфейс \\ среды разработки AppCode}
  \label{fig:appcode}
\end{figure}

Несмотря на большое количество достоинств интегрированной среды разработки AppCode,
не стоит воспринимать её как альтернативу приложению Xcode, так как
IDE от JetBrains не гарантирует полноценную поддержку приложений, написанных с
использованием Xcode. Зачастую разработкам iOS приложений, предпочитающим линейку
продуктов от JetBrains, приходится использовать две среды разработки для одного проекта.
Как правило, в таком случае разработчики используют Xcode для создания
пользовательских интерфейсов с использованием инструмента Interface Builder,
работы с мобильной базой данных CoreData, а написание кода приложения, а также
его отладку производят в интегрированной среде разработки AppCode.

Стоит отметить, что интегрированная среда разработки от JetBrains AppCode
является проприетарным программным обеспечением. Стоимость лицензионной версии AppCode
для индивидуального разработчика составляет приблизительно девяноста
долларов США в год, тогда как IDE Xcode от Apple распространяется через магазин
приложений AppStore на бесплатной основе.

Основными языками программирования, на которых ведётся разработка приложений для
устройств Apple являются Objective-C и Swift.

% Objective-C

Objective-C был придуман Брэдом Коксом в начале 1980-x годов
в качестве модификации языка программирования С в сторону Smalltalk.
Целью Кокса было создание языка, поддерживающего концепцию software IC.
Под этой концепцией понимается возможность собирать программы из готовых
компонент (объектов), подобно тому как сложные электронные устройства могут быть
легко собраны из набора готовых интегральных микросхем (IC, integrated circuits).
Эта модификация состояла в добавлении новых синтаксических
конструкций и специальном препроцессоре для них (который, проходя по коду
преобразовывал их в обычные вызовы функций С),
а также библиотеке времени выполнения (эти вызовы обрабатывающей).
Таким образом, изначально Objective-C воспринимался как надстройка над C.
В каком-то смысле это так и до сих пор: можно написать программу на чистом С,
а после добавить к ней немного конструкций из Objective-C (при необходимости),
или же наоборот, свободно пользоваться С в программах на Objective-C.

В 1988 году компания NeXT (а в последствии Apple)
лицензировала Objective-C и написала для него компилятор и
стандартную библиотеку (SDK).
В 1992 году к усовершенствованию языка и компилятора подключились разработчики
проекта GNU в рамках проекта OpenStep. С тех пор компилятор GCC поддерживает Objective-C.
После покупки NeXT, Apple взяла их SDK (компилятор, библиотеки, IDE) за основу
для своих дальнейших разработок. IDE для кода назвали Xcode,
а для GUI --– Interface Builder.
Фреймворк Cocoa, используемый в основном для разработки графического интерфейса пользователя,
на сегодняшний день является наиболее значимой средой разработки программ на Objective-C.

Файлы модулей на языке Objective-C имеют расширение \textit{.m}
(если использовалась смесь С++ и Objective-С, то расширение \textit{.mm}),
заголовочные файлы --– \textit{.h}. Все создаваемые в Objective-С объекты классов
должны размещаться в динамической памяти. Поэтому особое значение приобретает
тип \textit{id}, который является указателем на объект любого класса (\textit{void *}).
Нулевой указатель именуется константой \textit{nil}.
Таким образом, указатель на любой класс можно привести к типу \textit{id}.
Возникает проблема: как узнать к какому классу относится объект,
скрывающийся под \textit{id}? Это делается благодаря инварианту \textit{isa},
который присутствует в любом объекте класса, унаследовавшего специальный
базовый клас \textit{NSObject} (приставка NS обозначает NeXT Step).
Инвариант \textit{isa} относится к зарезервированному типу \textit{Class}.
Объект такого типа позволяет узнавать имена своего и базового класса,
набор инвариантов класса, а также прототипы всех методов,
которые реализовал этот объект и их адреса (посредством локального списка селекторов).
Все зарезервированные слова Objective-C, отличающиеся от зарезервированных
слов языка С, начинаются с символа \@ (например \textit{@protocol, @selector, @interface}).
Обычно имена инвариантов классов с ограниченной
областью видимости (\textit{@private, @protected}) начинаются с
символа подчеркивания~\cite{objective_c_from_scratch, appledoc_ios}.


% Swift

В 2014 году на конференции The Apple Worldwide Developers Conference Apple
представила язык программирования Swift --– новый язык программирования
для разработки iOS и OS X приложений, который сочетает в себе все лучшее от C и Objective-C,
но лишен ограничений, накладываемых в угоду совместимости с C.
В Swift используются паттерны безопасного программирования и добавлены
современные функции, превращающие создание приложения в простой,
более гибкий и увлекательный процесс. Swift, созданный с чистого листа, ---
это возможность заново представить себе, как разрабатываются приложения.

На разработку нового языка программирования у Apple ушло около четырёх лет.
Основой нового языка программирования послужили существующие компилятор,
отладчик и фреймворки. Разработчики языка упростили процесс управления памятью
с помощью механизма автоматического подсчета ссылок --- Automatic Reference Counting (ARC).
Фреймворки также подверглись серьезной модернизации. Objective-C начал
поддерживать блоки, литералы и модули --- все это создало благоприятные условия
для внедрения современных технологий. Именно эта подготовительная работа
послужила фундаментом для нового языка программирования,
который будет применяться для разработки будущих программных продуктов для Apple.

Swift вобрал в себя всё лучшее от современных языков и разработан с учетом
обширного опыта компании Apple. Компилятор для Swift --- синоним производительности,
язык оптимизирован для разработки без оглядки на компромиссы.
Он спроектирован таким образом, чтобы вы смогли легко разработать
и ваше первое приложение \textit{«hello, world!»}, и даже целую операционную систему.
Все это делает Swift важным инструментом для разработчиков и для самой компании Apple.

Swift работает в 2,6 раза быстрее, чем Objective-C. Apple включила поддержку
динамических библиотек, которые потребляют меньше ресурсов системы и поставляются,
обновляются отдельно от исполняемых файлов приложений.
В результате готовая программа занимает меньше памяти на устройстве.

В декабре 2015 года, вместе с выходом второй версией языка, компания Apple
объявила от открытии исходного кода Swift.
По словам Федериги, вице-президент Apple по разработке ПО, язык Swift уже
стал самым популярным среди разработчиков на веб-хостинге GitHub.
И создатели Swift сейчас активней всех остальных общаются со сторонними разработчиками.
Внутри самой компании программисты стараются максимально использовать Swift
в своей работе. Это и команда разработчиков iCloud, и разработчики OS X,
которые переводят некоторые аспекты платформы на новый язык (к примеру,
управление окнами). По мнению многих, этот простой язык более практичен в разработке.
Благодаря открытому исходному коду Swift теперь можно внедрять
в школы в качестве базы для обучения программированию. Об этом же говорил
и Тим Кук, посетив лекцию <<Hour of Code>> в нью-йоркском Apple Store.
Федериги даже уверен, что в ближайшие 20 лет Swift станет самым
используемым языком программирования~\cite{federighi_about_swift, habr_swift}.

Язык Swift является совместимым с предыдущим языком Apple Objective-C,
что позволяет разработчикам использовать библиотеки, написанные на Objective-C,
а также вести разработку текущих проектов на новом языке, не ограничиваясь
использованием языка Swift только в новых проектах.

Для обеспечения работы мобильных приложений в оффлайн-режиме требуется
использовать некоторое хранилище данных.

В зависимости от объёма информации, хранение данных может осуществляться
различными способами. Например, если объём информации небольшой, то для
сохранения данных может быть достаточно представить эту информацию
в виде последовательности битов и записать её в файл на жестком диске устройства.
Если же объём информации большой, или же представляет собой набор однотипных данных,
которые легко представить в виде объектов, то имеет смысл сохранять данные
с использованием мобильных баз данных.

Учитывая набор входных данных приложения, рассмотренный в подразделе~\ref{subs:dataware},
целесообразным является использование мобильной базы данных. На сегодняшний день
наиболее распространенными вариантами реализации мобильной базы данных являются:
\begin{itemize}
  \item CoreData;
  \item SQLite;
  \item Realm.
\end{itemize}

CoreData представляет собой высокоуровневую реализацию локальных баз данных от Apple,
которая по средством использования Objective-C или Swift функций
выполняет запросы к базе данных SQLite.

Несмотря на наличие высокоуровневого интерфейса для использования SQLite,
возникают случаи, когда необходимо работать с базой данных SQLite напрямую.
Потребность в таком подходе может возникнуть при оперировании очень большими
объёмами данных, где крайне важна оптимизация в выполняемых SQL-запросах.

В 2015 году была представлена кроссплатформенная мобильная база данных Realm.
Realm была создана, чтобы стать лучше и быстрее, чем SQLite и Core Data.
Действительно, например, запросы подсчёта записей в таблице по запросу,
выполняются примерно в 2 раза быстрее, чем с использованием SQLite,
а по сравнению с CoreData разница в скорости выполнения операций составляет
приблизительно 15 раз.

Мобильная база данных является Realm не только высокопроизводительной,
но и достаточно простотой в использовании, так, разработчикам предоставляется возможность
сделать многое с помощью всего нескольких строк кода. Realm является
совершенно бесплатной, можно использовать ее без каких-либо ограничений~\cite{todo_swift_realm}.


Таким образом, благодаря покрытию абсолютно всех этапов разработки приложения,
в качестве среды разработки программного модуля будет использована IDE Xcode,
языки программирования --- Objective-C и Swift.
В качестве хранилище данных будет использована кросс-платформенная мобильная
база данных Realm, так она сочетает в себе высокую производительность,
удобство использования, а также высокую надёжность выполняемых операций.

\pagebreak


% Реализация структуры программного модуля

\subsection{Реализация структуры программного модуля}

С учётом постановки задачи, изложенной в подразделе~\ref{subs:task_definition},
а также основанной но ней диаграмме декомпозиции верхнего уровня,
проиллюстрированной на рисунке~\ref{fig:idef0}, разрабатываемое
приложение следует разделить на подсистемы, у каждой из которых будут
определенные функциональные обязанности.

Так, например, при наиболее очевидном варианте использования приложения,
можно выделить следующие функциональные блоки системы:
\begin{itemize}
  \item загрузка данных с внешних серверов или из БД (ввод данных);
  \item выбор валюты (по умолчанию осуществляется автоматически);
  \item подготовка данных для отображения (фильтрация, сортировка);
  \item вывод данных на экран.
\end{itemize}

Для наглядного отображения приведём структура программного модуля,
разделенного на подсистемы в виде диаграммы, построенной по методологии IDEF0.
Диаграмма декомпозиция программного модуля приведена
на рисунке~\ref{fig:idef0_structure}.
\begin{figure}[h!]
  \centering
  \includegraphics[width=160mm]{fig/IDEF0_structure}
  \caption{Диаграмма декомпозиции программного модуля}
  \label{fig:idef0_structure}
\end{figure}

Разработка нативных приложений для платформы iOS предполагает использования
библиотеки UIKit, разработанной компанией Apple. Эта библиотека представляет
собой набор спецификация для создания графического интерфейса пользователя.

\pagebreak

Базовой сущностью библиотеки UIKit является элемент представления \textit{UIView}.
Сущность \textit{UIViewController} предоставляет интерфейс для управления отображением
элементов представления на экран устройства. Одному экрану приложения соответствует
одна сущность UIViewController, в результате выполняется разделение
логики приложения по этим сущностям, а также их вспомогательным файлам --- сервисам.

Для грамотного построения логики приложения, а также корректной реализации графического
интерфейса пользователя важно понимать жизненный цикл сущности \textit{UIViewController},
который представлен на рисунке~\ref{fig:vc_lifecycle}.
\begin{figure}[h!]
  \centering
  \includegraphics[width=120mm]{fig/vc_lifecycle}
  \caption{Жизненный цикл сущности \textit{UIViewController}}
  \label{fig:vc_lifecycle}
\end{figure}

\newpage


% Реализация подсистемы загрузки данных

\subsection{Реализация подсистемы загрузки данных}
\label{subs:realization_network_requests}

Подсистема загрузки данных приложения представляет собой независимый блок,
на вход которому поступает адрес интерфейса прикладного программирования (API),
выходом служат данные, готовые для дальнейшей обработки и сохранения
в мобильной базе данных.

Адрес API финансового портала myfin.by является параметрическим,
в качестве параметра выступает уникальный код областного центра Республики Беларусь.
Таким образом, построение результирующего URL выполняется путём конкатенации
статической строки адреса API и кода областного центра.
Соответствие областных центров конечным URL сведены в таблицу~\ref{tbl:url_by_city}.
\begin{table} [h!]
  \caption{
    Соответствие наименований областных центров конечным \\
    \hspace{29.5mm} URL финансового портала myfin.by
  }\label{tbl:url_by_city}
    \begin{tabular}{| m{4.75cm} | c | c |}
      \hline

      Наименование \newline областного центра & Код  города & Конечный URL \\
      \hline

      г. Минск    & 1 & http://admin.myfin.by/outer/authXml/1 \\ \hline
      г. Витебск  & 2 & http://admin.myfin.by/outer/authXml/2 \\ \hline
      г. Гомель   & 3 & http://admin.myfin.by/outer/authXml/3 \\ \hline
      г. Гродно   & 4 & http://admin.myfin.by/outer/authXml/4 \\ \hline
      г. Брест    & 5 & http://admin.myfin.by/outer/authXml/5 \\ \hline
      г. Могилёв  & 6 & http://admin.myfin.by/outer/authXml/6 \\ \hline

    \end{tabular}
\end{table}

Стоит отметить, что доступ к приведенным в таблице~\ref{tbl:url_by_city} адресам
ограничен. Существует два варианта получение доступа со стороны финансового портала:
использование выделенного (статического) IP-адреса, или же http-запрос,
включающий в себя процесс авторизации. Учитывая то, что разрабатываемый
программный модуль в широком смысле является приложением-клиентом,
которое будет запускаться на различных устройствах,
то использование статического IP-адреса становиться невозможным. В результате,
по договорённости с финансовым порталом myfin.by, для разрабатываемого
программного модуля был выделен логин и пароль, с помощью которого будет
выполнятся http-запрос с авторизацией.

Для получения данных о курсах валют, установленных Национальным банком Республики
Беларусь, требуется выполнить параметрический запрос:

\textit{http://www.nbrb.by/Services/XmlExRates.aspx?ondate=\{date\}}, \\
где в качестве параметра \textit{date} выступает дата, записанная в определённом
формате.

Обращая внимание на количество аналогичных http-запросов, а также их схожесть
(запросы являются параметрическими, ответом на запрос выступают данные в формате XML,
или информация об ошибке), целесообразным является создание интерфейса выполняемых
сетевых операций. Для этого в языке Swift используются протоколы.

\textit{Протокол} определяет образец методов, свойств или другие требования,
которые соответствуют определенному конкретному заданию или какой-то функциональности.
Протокол фактически не предоставляет реализацию для любого из этих требований,
он только описывает как реализация должна выглядеть. Протокол может быть принят классом,
структурой или перечислением для обеспечения фактической реализации этих требований.
Любой тип, который удовлетворяет требованиям протокола,
имеет указание соответствовать этому протоколу.

В дополнение к определенным требованиям, которые должны быть реализованы
подписанными под протокол типами, можно также расширить протокол, чтобы реализовать
некоторые из этих требований или для того, чтобы реализовать дополнительную
функциональность, которую смогут использовать подписанные под протокол
типы~\cite{swiftbook_protocols}.

Для определения общего интерфейса выполняемых сетевых операций создадим
протокол \textit{Operation}, который в дальнейшем, будет реализован дочерними классами.
Определение протокола Operation приведено на рисунке~\ref{lst:protocol_operation}.
\lstinputlisting[
    caption=Определение протокола \textit{Operation},
    label=lst:protocol_operation,
]{lst/protocol_operation.lst}

Функция \textit{startWithCompletion:} является основной для протокола Operation,
так как именно её будут реализовывать классы, подписавшиеся на следование
данному протоколу.

Нетрудно заметить, что реализация функции \textit{networkRequestForURL:} для всех
наследников протокола \textit{Operation} будет одинаковой. Таким образом, имеет смысл
реализовать эту функцию на уровне протокола. Это обеспечит
доступ к реализованной функции всем подписчикам протокола \textit{Operation},
без необходимости написания однотипной реализации данной функции.
Реализация функции на уровне протокла (по умолчанию) в языке Swift выполняется с помощью
конструкции расширения.

\textit{Расширения} добавляют новую функциональность существующему типу класса,
структуры или перечисления. Это включает в себя возможность расширять типы,
к исходным кодам которых у вас нет доступа (известно как ретроактивное
моделирование)~\cite{swiftbook_extensions}.

Расширение протокола \textit{Operation} приведено на рисунке~\ref{lst:operation_extension}.
\lstinputlisting[
    caption=Расширение протокола \textit{Operation},
    label=lst:operation_extension,
]{lst/operation_extension.lst}

Приведенная функция \textit{networkRequestForURL:} служит для выполнения сетевых
операций при заданном URL. Блок \textit{completion} служит для обратной связи
с вызывающей функцией и будет вызван тогда, когда сетевая операция завершится.

Таким образом, протокол \textit{Operation}, а также его расширение, позволят
существенно упростить логику, а также выполнение всех сетевые операции
в едином логическом стиле независимо от классов, подписанных на данный протокол.
Классами, которые подписаны на протокол \textit{Operation} являются:
\textit{MyFinOperation}, \textit{NationalBankOperation} и \textit{GeocodeOperation}.

Класс \textit{MyFinOperation} реализует логику сетевого запроса к API
финансового портала myfin.by.

Класс \textit{NationalBankOperation} реализует логику сетевого запроса к API
сайта Национального банка Республики Беларусь.

Класс \textit{GeocodeOperation} используется для преобразования адреса,
представленного в виде строки в координаты широты и долготы.

Реализация функций \textit{startWithCompletion:} и \textit{operationForCity:},
описанных в классе \textit{MyFinOperation}, представлена
на рисунке~\ref{lst:start_with_completion_realization}.
\lstinputlisting[
    caption=Реализация функции \textit{startWithCompletion:},
    label=lst:start_with_completion_realization,
]{lst/start_with_completion_realization.lst}

В приведенной на рисунке~\ref{lst:start_with_completion_realization} функции
выполняется создание отдельного потока для выполнения запроса, а также
последующей обработки информации. Функция \textit{parseMyFinResponse:} выполняет
преобразование полученных с сервера данных в объекты модели данных.

Полный исходный код реализации класса \textit{MyfinOperation} приведен в приложении~А.

\pagebreak


% Реализация подсистемы хранения данных

\subsection{Реализация подсистемы хранения данных}
\label{subs:impl_storage}

Мобильная база данных Realm является объектно-ориентированной,
для сохранение какой-либо информации в ней требуется создание классов
модели данных, унаследованных от класса \textit{Object} модуля \textit{Realm}.
Несмотря на ограниченное количество поддерживаемых типов данных,
Realm обеспечивает полноценное покрытие спроектированной в
подразделе~\ref{subs:dataware} модели данных.

Так, сущности <<Банк>> соответствует класс \textit{Bank}, сущности <<Отделение>>
соответствует класс \textit{Department}, а сущности <<Курс>> ---
класс \textit{ExchangeRates}. Рассмотрим реализацию класса \textit{Bank},
приведенного на рисунке~\ref{lst:bank}, подробнее.
\lstinputlisting[
    caption=Реализация класса модели данных \textit{Bank},
    label=lst:bank,
]{lst/bank.lst}

В приведенном классе описаны поля \textit{id, name, website}, отражающие
уникальный идентификатор банка, название, а также сайт, если
информация о нём предоставлена. Поле \textit{departments} содержит список
отделений конкретного банка. Этот список инициализируется при создании объекта
класса \textit{Bank}, количество элементов в нём может изменяться.

Модификатор \textit{private(set)} служит для ограниченного доступа
к свойствам объекта, таким образом, чтобы они были доступны только для чтения.
Ключевое слово \textit{dynamic} существует для корректной интерпретации и поддержки
времени выполнения языка Objective-C.

Полный исходный код реализации модели данных программного модуля
приведен в приложении~Б.

Очевидно, что отображение получаемых в формате XML данных от API финансового
портала myfin.by в рассматриваемую модель данных в автоматическом режиме
выполнить невозможно. Поэтому, для выполнения данной операции требуется создать
структуру \textit{DepartmentXMLMap}, которая будет являться вспомогательной
на пути преобразования информации из формата XML в объекты модели данных,
пригодные для сохранения в Realm.

Реализация вспомогательной структуры \textit{DepartmentXMLMap} представлена
на рисунке~\ref{lst:departments_xml_map}.
\lstinputlisting[
    caption=Реализация вспомогательной структуры \textit{DepartmentXMLMap},
    label=lst:departments_xml_map,
]{lst/departments_xml_map.lst}

Для удобства работы с множеством кодов областных центров Республики Беларусь,
имеет смысл создать перечисление. Для этого в языке Swift существует
конструкция \textit{Enum}.
Перечисления определяют общий тип для группы связанных значений и позволяют
работать с этими значениями в типобезопасном режиме.

Исходный код перечисления \textit{City} представлен на рисунке~\ref{lst:city_enum}.
\lstinputlisting[
    caption=Реализация перечисления \textit{City},
    label=lst:city_enum,
]{lst/city_enum.lst}

Благодаря широким возможностям перечислений в языке Swift, а именно
возможности использования функций, вычисляемых полей, получение URL в
зависимости от областного центра заметно упрощается. Так, используя объект
перечисления \textit{City}, для получения правильного URL достаточно
будет вызвать функцию \textit{myfinURL:} этого объекта.









\pagebreak


% Реализация подсистемы отображения информации

\subsection{Реализация подсистемы отображения информации}
% \pagebreak


% Реализация пользовательского интерфейса

\subsection{Реализация пользовательского интерфейса}
% завязать на жизненный цикл ViewController-а, можно приложения в целом
% \pagebreak


% Руководство пользователя

\subsection{Руководство пользователя}
% \pagebreak


% Перспективы развития

\subsection{Перспективы развития}
\pagebreak
