\section[Реализация программного модуля]{%
  РЕАЛИЗАЦИЯ ПРОГРАММНОГО МОДУЛЯ
}\label{sec:implementation}

Данный раздел содержит подробное описание деталей реализации
мобильного приложения, дополняя и уточняя
содержание раздела~\ref{sec:design}.

\subsection{Выбор программных средств реализации}

Мобильная платформа Android в значительной мере
определяет набор средств разработки. Большинство Android-приложений
разрабатываются на языке программирования Java. Программирование
приложения производится c помощью специализированной
IDE Android Studio с использованием Android Software Developement Kit (SDK).

Существует некоторая свобода выбора в отношении используемой СУБД.
Следует отметить, что системы управления базами данных,
используемые на мобильных платформах, существенно отличаются
от традиционных решений.
Это вызвано тем, что работа мобильных баз данных производится в
несколько иных условиях:
\begin{itemize}
  \item малый рабочий объем данных;
  \item низкая плотность потока запросов обработки данных;
  \item отсутствие необходимости обработки параллельных транзакций;
  \item программный интерфейс приложения-клиента заранее известен.
\end{itemize}

Первые три условия вызваны тем, что СУБД обрабатывает запросы
лишь одного клиента --- пользователя приложения.
Последнее условие вызвано тем, что программный интерфейс мобильных
приложений для платформы Android известен по определению (Java VM).

С другой стороны, мобильные платформы выдвигают ряд
дополнительных требований к СУБД.
Во-первых, работа базы данных должна производиться в рамках
процесса клиентского приложения, поскольку Android не гаратирует
неприкосновенности пользовательских процессов, то есть они могут быть
приостановлены или завершены в любой момент времени.
Во-вторых, механизм хранения данных должен быть централизованным,
компактным и переносимым. Это требование накладывает
известные ограничения на используемые структуры данных
и алгоритмы их обработки.

Существует несколько популярных СУБД для мобильных устройств.
По умолчанию Android предоставляет возможность хранения
данных с использованием SQLite --- малой реляционной СУБД,
используемой также и на персональных компьютерах.
Характерными особенностями данной СУБД являются поддержка SQL,
хранение данных в едином файле и отсутствие необходимости конфигурирования.
Кроме этого, существует несколько альтернативных СУБД~\cite{mobile_db}:
Cupboard, BerkeleyDB, Couchbase Lite, LevelDB, Realm, UnQLite.

В разрабатываемом приложении используется СУБД Realm~\cite{realm_official}.
Выбор обусловлен следующими причинами:
\begin{itemize}
  \item Realm является объектно-ориентированной СУБД,
    что избавляет от необходимости написания слоя трансляции объектов Java
    в сущности реляционной БД;
  \item разработчики Realm заявляют о достаточно высокой производительности
    своего решения;
  \item проект активно развивается, является открытым,
    бесплатным для коммерческого использования
    и имеет подробную документацию.
\end{itemize}

Кроме этого, разрабатываемое приложение использует библиотеку OpenCV
для обработки и распознавания изображений, а также библиотеки Appcompat
(реализация рекомендаций Material Design на старых версиях платформы Android)
и JUnit (используется при тестировании приложения).

\subsection{Реализация подсистемы хранения данных}
\label{subsec:implementation_db}

Поскольку Realm является объектно-ориентированной СУБД,
сущности модели данных, разработанной в подразделе~\ref{subsec:design_information},
находят свое прямое отражение в классах Java.
При этом Realm предъявляет дополнительные требования
к интерфейсу классов модели данных:
\begin{itemize}
  \item данные классы должны быть унаследованы от \texttt{RealmObject};
  \item каждый класс иметь публичный конструктор без параметров,
    а также набор соответствующих методов доступа/модификации полей данных;
  \item набор типов хранимых данных ограничен набором базовых типов,
    а также другими классами модели данных.
\end{itemize}

Realm поддерживает хранение следующих базовых типов данных:
\texttt{boolean}, \texttt{byte}, \texttt{short}, \texttt{ìnt},
\texttt{long}, \texttt{float}, \texttt{double}, \texttt{String},
\texttt{Date} и \texttt{byte[]}.
Кроме этого, поддерживается возможность создания отношений вида
1:1, 1:M, M:M путем хранения наборов ссылок на другие объекты Realm
в виде списков (\texttt{RealmList}).

На рисунке~\ref{lst:implementation_db_account} представлен класс
\texttt{Account}, соответствующий сущности <<УчетнаяЗапись>> исходной
модели данных.
Рассмотрим элементы данного класса.
Данный класс является публичным, унаследованным от класса \texttt{RealmObject}.
Он содержит набор приватных полей данных: название, индекс, код валюты,
а также список связанных объектов \texttt{BalanceChange},
соответствующих изменениям баланса.
Кроме этого, он содержит публичное строковое поле, соответствующее
названию поля индекса и используемое для сортировки.

\lstinputlisting[
    caption=Пример класса модели данных,
    language={Java},
    label=lst:implementation_db_account,
]{lst/implementation_db_account.lst}

Большинство методов класса выполняют тривиальные чтение/модификацию
полей объекта; метод \texttt{getBalanceChanges} возвращает ссылку на
список связанных изменений баланса,
а метод \texttt{getTotalAmount} использует встроенную
агрегатную функцию для получения суммы значений данных изменений.

Доступ к подсистеме базы данных осуществляется через класс
\texttt{DBManager}. Данный класс представляет собой синглтон,
выполняющий инициализацию и контроль доступа к объектам \texttt{Realm}
стороны подсистемы обработки данных.

Полный исходный код реализации модели данных представлен в приложении~А.

\subsection{Реализация подсистемы компьютерного зрения}
\label{subsec:implementation_cv}

Подсистема компьютерного зрения реализована на базе библиотеки
OpenCV и носит экспериментальный характер.

\subsection{Реализация пользовательского интерфейса}
\label{subsec:implementation_ui}

Данный подраздел рассматривает детали реализации пользовательского
интерфейса приложения.
Вначале рассматриваются принципы организации программного
графического интерфейса платформы Android в целом,
далее описывается подход к обработке и отображению пользовательских данных,
затем приводится подробное описание элементов интерфейса различных
экранов приложения, введенных в подразделе~\ref{subsec:design_structure}.

Графический интерфейс платформы Android базируется на трех классах:
\texttt{Activity}, \texttt{Fragment} и \texttt{View}.
Класс \texttt{Activity} (экран) соответствует отдельному экрану приложения.
Класс \texttt{Fragment} (фрагмент) соответствует относительно самостоятельной части
экрана приложения.
Экраны и фрагменты содержат множество экземпляров класса \texttt{View},
соответствующего базовым элементам интерфейса --- полям, кнопкам, и~т.~д.
Взаимосвязь этих классов приведена на рисунке~\ref{fig:implementation_ui_hierarchy}.

\begin{figure}[h!]
  \centering
  \fcolorbox{gray}{white}{
    \includegraphics[width=140mm]{fig/implementation_ui_hierarchy.eps}
  }
  \caption{Организация базовых классов \\ пользовательского интерфейса Android}
  \label{fig:implementation_ui_hierarchy}
\end{figure}

Введение понятия фрагмента обусловлено необходимостью унификации
механизма поддержки пользовательского интерфейса для устройств с различным
размером дисплея. Так, например, на устройствах с большим размером дисплея
один экран приложения может содержать несколько фрагментов, а на малом ---
каждый фрагмент будет находиться в отдельном экране.
Связь между экраном и фрагментом осуществляется явно:
экраны хранят ссылки на созданные ими фрагменты,
а фрагменты могут получить ссылку на родительские экраны путем
вызова метода \texttt{getActivity}.
Для получения ссылки на требуемый объект класса \texttt{View}
используется метод \texttt{findViewById}.

Платформа Android управляет экранами и фрагментами путем вызова ряда методов,
определенных в базовых классах. Совокупность данных методов образует
жизненный цикл элемента интерфейса. Каждый из них принимает
специльный аргумент типа \texttt{Bundle}, позволяющий передавать
аргументы примитивных типов, а также сохранять и восстанавливать
собственное состояние.
На рисунке~\ref{fig:implementation_ui_lifecycle_activity}
представлена схема жизненного цикла экрана приложения.

\begin{figure}[h!]
  \centering
  \fcolorbox{gray}{white}{\input{fig/implementation_ui_lifecycle_activity.tex}}
  \caption{Жизненный цикл экрана приложения}
  \label{fig:implementation_ui_lifecycle_activity}
\end{figure}

При создании экземпляра \texttt{Activity} вызывается метод \texttt{onCreate}.
Типичная реализация данного метода предполагает инициализацию
всех вложенных элементов интерфейса.
Далее вызываются методы \texttt{onStart}, \texttt{onResume},
и данный экран получает фокус.
При открытии различных вспдывающих окон у родительского экрана вызывается
метод \texttt{onPause}, а при переходе на другой экран --- \texttt{onStop}.
Пара методов \texttt{onPause}/\texttt{onResume} обычно используется для
сохранения/загрузки промежуточных результатов работы экрана.
Метод \texttt{onDestroy} вызывается при закрытии приложения.
Данный метод часто переопределяется для освобождения используемых ресурсов.
Отметим, что жизненный цикл фрагмента имеет несколько более сложный вид
и связан с жизненным циклом родительского экрана.

Рассмотрим задачу организации форматирования и валидации данных,
вводимых пользователем.
Пользователь приложения должен иметь возможность ввода данных в
различные поля приложения.
Классы пользовательского приложения должны выполнять валидацию и форматирование
введенных данных и предоставлять их подсистеме обработки данных в совместимой форме.
Кроме этого, они должны поддерживать возможность автоматического
заполнения полей форматированными значениями в случае, если они заполнялись раньше.
Ситуация усложняется тем, что представление данных с точки зрения классов
пользовательского интерфейса Android и классов подсистемы обработки данных
приложения могут различаться.
Для решения данной задачи была разработан набор классов, представленный
на рисунке~\ref{fig:implementation_ui_edit_manager}.

\begin{figure}[h!]
  \centering
  \fcolorbox{gray}{white}{
    \includegraphics[width=140mm]{fig/implementation_ui_edit_manager.eps}
  }
  \caption{Диаграмма классов обработки данных, вводимых пользователем}
  \label{fig:implementation_ui_edit_manager}
\end{figure}

В нем определяются интерфейсы параметризованные интерфейсы
\texttt{IEditManager}, \texttt{IFormatter}, \texttt{IFormatter}
и набор их реализаций, связанных друг с другом. Рассмотрим каждый из них более подробно.

Интерфейс \texttt{IFormatter} используется для форматирования некоторого входного
значения заданного типа, определенного шаблоном интерфейса.
Результатом работы его единственного метода данного интерфейса является строка,
пригодная для размещения в элементе пользовательского интерфейса.

Метод \texttt{validate} интерфейса \texttt{IValidator} предназначен для
конвертации строки-параметра, сответствующей пользовательскому вводу,
в тип данных, совместимый с подсистемой обработки данных. В случае,
если подобная конвертация оказывается невозможной, он возбуждает
стандартное исключение типа \texttt{IllegalArgumentException}.

Интерфейс \texttt{IEditManager} определяет протокол взаимодействия
между фрагментом приложения, полем ввода данных
и подсистемой обработки данных.
Он имеет три метода, первые два из которых используются
для установки и получения последнего корректного введенного значения
в совместимом формате соответственно, а третий используется для проверки,
содержит ли поле ввода корректное значение в данный момент.

Взаимодействие описанных сущностей осуществляется следующим образом.
Экран или фрагмент в ходе своего жизненного цикла создают экземпляр класса,
реализующего интерфейс \texttt{IEditManager} и связывают его с целевыми
полями ввода и прочими вспомогательными объектами.
Каждая конкретная реализация интерфейса \texttt{IEditManager}
создает необходимые ей экземлпяры классов,
реализующих интерфейсы \texttt{IFormatter}
и \texttt{IValidator}, и использует их в своей реализации,
подставляя результаты вызова методов объектов классов, реализующих
эти интерфейсы, в качестве собственных выходных значений.

% Иерархия элементов UI. Связи элементов. Жизненный цикл элементов UI.

% Классы ввода и обработки данных.

% Экраны приложения.

\subsection{Реализация подсистемы обработки данных}
\label{subsec:implementation_bl}

Связь UI и BL. Использование интерфейсов для Presenters.


% Реализация алгоритма распознавания изображений (OpenCV).

\subsection{Тестирование программного модуля}

Использование объектов типа Presenter позволяет упростить
тестирование компонентов приложения.
Понятие юнит- и инструментальных тестов.
Тестирование (Unit \& Instrumental tests).

\subsection{Руководство пользователя}

Установка приложения из Google Play.
Ввод данных. Просмотр данных. Группировка.
Скриншоты.

\subsection{Перспективы развития}

Сортировка категорий на основании данных геолокации.
% Распознавание суммы по чеку.